---
layout: post
title: "Go tips"
---
* [Basics](#basics)
* [Data Structures](#data-structures)

## Basics

1. Hello World:

    ```go
    package main

    import (
        "fmt"
        "strings"
        "math/rand"
        "time"
        "github.com/headfirstgo/keyboard" // use go get to download the package
    )

    func main() {
        fmt.Println("Hello Go!")
        fmt.Println(strings.Title("head first go"))
        rand.Seed(time.Now().Unix())
        fmt.Println(rand.Intn(100)) // 0 - 99
    }
    ```

2. Use `go fmt` to format the code. (Go uses tabs instead of spaces.)

3. Use `go run` to compile and run. Or `go build` and `./foo`. `go install` generates the binary in the bin directory.

4. Rune literals are surrounded by single quotes. (Just like C chars.)

5. Initialization:

    ```go
    var foobar bool // the zero (default) value is false
    // The zero values: 0 for int and float; false for bool
    foo := 42 // short variable declaration
    // ONLY ONE variable in the short variable declaration has to be new
    // This allows multiple err for definitions
    ```

6. Go prefers the camelCase and no semicolons.

7. Type conversions:

   * Go uses the C-like style type conversion: `length = float64(width)`
   * And similarly for string to int: `foo, err := strconv.Atoi("123")` (ASCII to Int)

8. Go doesn't allow variable declarations unless we use these variables.

9. We can use the blank identifier just like in Swift:

    ```go
    reader := bufio.NewReader(os.Stdin)
    input, _ := reader.ReadString('\n') // if we don't handle the err
    // or we handle it:
    // if err != nil {
        // log.Fatal(err)
    //}
    ```

10. Like in Swift/Python, there's no need to add parentheses for `if` and `for`.

11. Since Go is syntactically similar to C, it also uses the formatting verbs: `%f`, `%d`, `%s`, `%t` (Boolean), `%v` (Any.) (`%2d` and `%.2f` are also used to round the numbers.)

12. Like in Swift and Kotlin, the types are after the parameter names in a function:

    ```go
    func foo(bar string, foobar int) string {
        return "Hello Go!"
    }

    func foofoo() (string, string) {
        return "Hello", "Go!"
    }
    ```

13. Go is a "pass-by-value" language by default. And we have the C-style pointers and addresses. A shorter form: `fooPointer := &foo`

14. `const fooBar = 42` or `const fooBar int = 42`

15. Documentations:
    * `go doc strconv` to see the documentation of strconv.
    * `go doc strconv Atoi` to see the specific function.
    * `godoc -http=:6060` starts the local server at port 6060.

16. Add ordinary comments before the package line and before functions to make them doc comments. A few conventions:
    * Comments should be complete sentences.
    * Package comments should begin with "Package + name": `// Package myPackage does nothing.`.
    * Function comments should begin with the function name: `// MyFunction does nothing.`.

17. `import ("os")` and `os.Args[1:]` gives the command-line arguments (except the file name).

18. Variadic functions: `func myFunc (param1 int, param2 ...string) {}` (unlimited string parameters)

## Data Structures

1. Arrays:
    * `var myArray [4]string`
    * `myArray := [2]int{3, 4}`
    * `fmt.Println(myArray)` (can be printed directly).
    * Like in Python, use `len(meArray)` to check the length.

2. For loops: `for index, value := range myArray`

    ```go
    for index, note := range notes {
        fmt.Println(index, note)
    }
    // or
    for _, note := range notes {
        fmt.Println(note)
    }
    // or
    for index, _ := range notes {
        fmt.Println(index)
    }
    ```

3. Slices: (similar to Python)
    * `var notes []string` then `notes = make([]string, 7)`
    * `notes := []string{"foo", "bar"}`
    * `myArray := [5]string{"a", "b, "c", "d", "e"}` `mySlice := myArray[1:3]` gives b, c.
    * We can also do `[1:]` or `[:3]`.
    * The modifications for the original array or the slice will affect each other.
    * `slice = append(slice, "foo", "bar", "foobar")`